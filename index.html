<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>여름 청춘 시뮬레이터</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Gowun+Dodum&display=swap');

  body {
    margin: 0; padding: 0; font-family: 'Gowun Dodum', sans-serif;
    background: #e3f2fd;
    color: #333;
    display: flex; flex-direction: column; height: 100vh;
  }

  header {
    background: #1565c0; color: white; padding: 12px 20px;
    font-size: 24px; font-weight: 700;
    text-align: center;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  }

  main {
    flex: 1;
    display: flex;
    gap: 12px;
    padding: 12px 20px;
    box-sizing: border-box;
    overflow: hidden;
  }

  #leftPanel {
    width: 320px;
    display: flex;
    flex-direction: column;
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 3px 8px rgba(0,0,0,0.1);
    overflow: hidden;
  }

  #studentList {
    flex: 1;
    overflow-y: auto;
    padding: 12px 10px;
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }

  .studentCard {
    background: #bbdefb;
    border-radius: 8px;
    padding: 8px 12px;
    box-shadow: 0 2px 6px rgba(21,101,192,0.4);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }

  .studentCard h4 {
    margin: 0 0 6px 0;
    font-weight: 700;
    font-size: 16px;
    color: #0d47a1;
  }

  .traits {
    font-size: 12px;
    color: #29457b;
    margin-bottom: 6px;
  }

  .relStatus {
    font-size: 12px;
    color: #3f51b5;
    margin-bottom: 6px;
    line-height: 1.2em;
    white-space: pre-line;
  }

  .btn-group {
    display: flex; gap: 6px;
  }

  button.btn-small {
    font-size: 12px;
    padding: 3px 8px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    background: #1976d2;
    color: white;
    transition: background-color 0.2s ease;
  }
  button.btn-small:hover {
    background: #0d47a1;
  }
  button.btn-danger {
    background: #e53935;
  }
  button.btn-danger:hover {
    background: #b71c1c;
  }

  #formContainer {
    background: #f5fafd;
    padding: 10px 14px;
    border-top: 1px solid #cfd8dc;
  }

  #formContainer label {
    font-weight: 700;
    font-size: 14px;
    margin-top: 8px;
    display: block;
    color: #0d47a1;
  }

  #formContainer input[type="text"],
  #formContainer input[type="number"],
  #formContainer select {
    width: 100%;
    padding: 6px 8px;
    margin-top: 4px;
    box-sizing: border-box;
    border-radius: 6px;
    border: 1.5px solid #90caf9;
    font-size: 14px;
    font-family: 'Gowun Dodum', sans-serif;
  }

  #traitsContainer {
    margin-top: 6px;
    min-height: 30px;
  }
  .traitTag {
    display: inline-block;
    background: #64b5f6;
    color: white;
    padding: 3px 7px;
    margin: 3px 3px 0 0;
    border-radius: 12px;
    font-size: 13px;
    cursor: default;
    user-select: none;
  }

  #initialLikesContainer {
    margin-top: 8px;
    max-height: 80px;
    overflow-y: auto;
    font-size: 12px;
  }
  #initialLikesContainer div {
    margin-bottom: 4px;
  }

  #addCharBtn, #cancelEditBtn {
    margin-top: 10px;
    padding: 8px 12px;
    font-weight: 700;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-size: 15px;
  }
  #addCharBtn {
    background: #1976d2;
    color: white;
  }
  #addCharBtn:hover {
    background: #0d47a1;
  }
  #cancelEditBtn {
    background: #ef5350;
    color: white;
    display: none;
  }
  #cancelEditBtn:hover {
    background: #b71c1c;
  }

  #rightPanel {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 3px 8px rgba(0,0,0,0.1);
  }

  #relationCanvas {
    width: 100%;
    height: 280px;
    border-bottom: 1px solid #cfd8dc;
    background: #e3f2fd;
    border-radius: 10px 10px 0 0;
  }

  #buttonsRow {
    padding: 10px 14px;
    display: flex;
    gap: 12px;
    justify-content: flex-start;
    background: #f0f7ff;
    border-bottom: 1px solid #cfd8dc;
  }
  #buttonsRow button {
    padding: 8px 12px;
    font-weight: 700;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    font-size: 14px;
    background: #1976d2;
    color: white;
    transition: background-color 0.2s ease;
  }
  #buttonsRow button:hover {
    background: #0d47a1;
  }

  #dateTitle {
    font-weight: 700;
    font-size: 18px;
    margin: 10px 16px 6px 16px;
    color: #0d47a1;
  }

  #dayLog {
    flex: 1;
    padding: 10px 16px;
    font-size: 14px;
    line-height: 1.5em;
    overflow-y: auto;
    color: #222;
    white-space: pre-line;
  }

  .popup {
    border-radius: 12px;
    padding: 8px 14px;
    margin-bottom: 10px;
    font-weight: 600;
    box-shadow: 0 0 8px rgba(0,0,0,0.12);
    user-select: none;
  }
  .popup.event {
    background: #bbdefb;
    border: 2px solid #1976d2;
    color: #0d47a1;
  }
  .popup.relationChange {
    background: #ce93d8;
    border: 2px solid #7b1fa2;
    color: #4a148c;
  }
  .popup.likeUp {
    background: #81d4fa;
    border: 2px solid #0288d1;
    color: #01579b;
  }
  .popup.likeDown {
    background: #ef9a9a;
    border: 2px solid #d32f2f;
    color: #b71c1c;
  }
</style>
</head>
<body>

<header>여름 청춘 시뮬레이터</header>
<main>
  <section id="leftPanel">
    <div id="studentList"></div>
    <div id="formContainer">
      <h3 id="formTitle">캐릭터 추가</h3>
      <form id="charForm">
        <label>이름</label>
        <input type="text" id="charNameInput" required autocomplete="off" />
        <label>나이</label>
        <input type="number" id="charAgeInput" min="10" max="30" required />
        <label>학년</label>
        <select id="charGradeSelect">
          <option value="1">1학년</option>
          <option value="2">2학년</option>
          <option value="3">3학년</option>
        </select>
        <label>성격 키워드 (엔터로 추가)</label>
        <input type="text" id="traitInput" autocomplete="off" placeholder="성격 키워드를 입력 후 엔터" />
        <div id="traitsContainer"></div>
        <label>초기 호감도 설정</label>
        <div id="initialLikesContainer" style="font-size:13px;"></div>
        <button id="addCharBtn" type="submit">추가</button>
        <button id="cancelEditBtn" type="button">취소</button>
      </form>
    </div>
  </section>

  <section id="rightPanel">
    <canvas id="relationCanvas"></canvas>
    <div id="buttonsRow">
      <button id="toggleStudentListBtn">학생 명단</button>
      <button id="toggleRelationBtn">관계도</button>
      <button id="nextDayBtn">다음 날</button>
      <button id="clearLogBtn">기록 삭제</button>
    </div>
    <div id="dateTitle"></div>
    <div id="dayLog"></div>
  </section>
</main>

<script>
  // 상태 저장
  const state = {
    characters: [],
    editingIndex: null,
    currentDate: new Date(2025, 2, 2), // 3월 2일부터 시작 (월은 0부터)
    logs: [],
    traitsUsedToday: new Set(),
  };

  // 이벤트 일정
  const events = [
    {name: '입학식', start: '2025-03-02', end: '2025-03-02'},
    {name: '1학기 중간고사', start: '2025-04-21', end: '2025-04-24'},
    {name: '1학기 기말고사', start: '2025-06-14', end: '2025-06-18'},
    {name: '여름방학', start: '2025-07-02', end: '2025-08-01'},
    {name: '수학여행', start: '2025-08-23', end: '2025-08-25'},
    {name: '체육대회', start: '2025-09-04', end: '2025-09-04'},
    {name: '2학기 중간고사', start: '2025-10-21', end: '2025-10-25'},
    {name: '2학기 기말고사', start: '2025-12-11', end: '2025-12-15'},
    {name: '종업식/졸업식', start: '2026-02-14', end: '2026-02-14'},
    {name: '봄방학', start: '2026-02-15', end: '2026-03-01'},
  ];

  // DOM
  const studentListDiv = document.getElementById('studentList');
  const formTitle = document.getElementById('formTitle');
  const charForm = document.getElementById('charForm');
  const charNameInput = document.getElementById('charNameInput');
  const charAgeInput = document.getElementById('charAgeInput');
  const charGradeSelect = document.getElementById('charGradeSelect');
  const traitInput = document.getElementById('traitInput');
  const traitsContainer = document.getElementById('traitsContainer');
  const initialLikesContainer = document.getElementById('initialLikesContainer');
  const addCharBtn = document.getElementById('addCharBtn');
  const cancelEditBtn = document.getElementById('cancelEditBtn');

  const relationCanvas = document.getElementById('relationCanvas');
  const toggleStudentListBtn = document.getElementById('toggleStudentListBtn');
  const toggleRelationBtn = document.getElementById('toggleRelationBtn');
  const nextDayBtn = document.getElementById('nextDayBtn');
  const clearLogBtn = document.getElementById('clearLogBtn');
  const dateTitle = document.getElementById('dateTitle');
  const dayLog = document.getElementById('dayLog');

  // 스크롤 및 토글용
  let showStudentList = true;
  let showRelation = true;

  toggleStudentListBtn.addEventListener('click', () => {
    showStudentList = !showStudentList;
    studentListDiv.style.display = showStudentList ? 'grid' : 'none';
  });
  toggleRelationBtn.addEventListener('click', () => {
    showRelation = !showRelation;
    relationCanvas.style.display = showRelation ? 'block' : 'none';
  });

  // 성격 키워드 배열
  let currentTraits = [];

  // traitsContainer 렌더링
  function renderTraits(){
    traitsContainer.innerHTML = '';
    currentTraits.forEach((t,i) => {
      const span = document.createElement('span');
      span.className = 'traitTag';
      span.textContent = t;
      span.title = '클릭해서 삭제';
      span.onclick = () => {
        currentTraits.splice(i, 1);
        renderTraits();
      };
      traitsContainer.appendChild(span);
    });
  }

  // traitInput 엔터 입력 시 키워드 추가
  traitInput.addEventListener('keydown', e => {
    if(e.key === 'Enter'){
      e.preventDefault();
      let val = traitInput.value.trim();
      if(val){
        // 쉼표가 있으면 자르기
        val = val.split(',')[0].trim();
        if(val && !currentTraits.includes(val)){
          currentTraits.push(val);
          renderTraits();
        }
        traitInput.value = '';
      }
    }
  });

  // 초기호감도 UI 업데이트
  function updateInitialLikesUI(){
    initialLikesContainer.innerHTML = '';
    if(state.editingIndex === null) {
      // 새 추가 시 - 모두 0
      state.characters.forEach(char => {
        const div = document.createElement('div');
        div.style.marginBottom = '4px';
        const label = document.createElement('label');
        label.textContent = `${char.name}에 대한 호감도: `;
        const input = document.createElement('input');
        input.type = 'number';
        input.min = -50;
        input.max = 100;
        input.value = 0;
        input.style.width = '50px';
        input.dataset.target = char.name;
        div.appendChild(label);
        div.appendChild(input);
        initialLikesContainer.appendChild(div);
      });
    } else {
      // 수정 시 - 기존 관계 불러오기
      const char = state.characters[state.editingIndex];
      state.characters.forEach(targetChar => {
        if(targetChar.name === char.name) return;
        const div = document.createElement('div');
        div.style.marginBottom = '4px';
        const label = document.createElement('label');
        label.textContent = `${targetChar.name}에 대한 호감도: `;
        const input = document.createElement('input');
        input.type = 'number';
        input.min = -50;
        input.max = 100;
        input.value = char.relationships[targetChar.name] || 0;
        input.style.width = '50px';
        input.dataset.target = targetChar.name;
        div.appendChild(label);
        div.appendChild(input);
        initialLikesContainer.appendChild(div);
      });
    }
  }

  // 학생 리스트 렌더링
  function renderStudentList(){
    studentListDiv.innerHTML = '';
    state.characters.forEach((char, idx) => {
      const card = document.createElement('div');
      card.className = 'studentCard';

      const title = document.createElement('h4');
      title.textContent = `${char.name} (${char.grade}학년, ${char.age}세)`;
      card.appendChild(title);

      if(char.traits.length > 0){
        const traitDiv = document.createElement('div');
        traitDiv.className = 'traits';
        traitDiv.textContent = '성격: ' + char.traits.join(', ');
        card.appendChild(traitDiv);
      }

      // 관계 상태 요약: 호감도+관계명
      const relDiv = document.createElement('div');
      relDiv.className = 'relStatus';
      let relStr = '';
      for(let targetName in char.relationships){
        const val = char.relationships[targetName];
        if(val >= 80) relStr += `${targetName}: 약혼자 (${val})\n`;
        else if(val >= 50) relStr += `${targetName}: 연인 (${val})\n`;
        else if(val >= 20) relStr += `${targetName}: 썸 (${val})\n`;
        else if(val > 0) relStr += `${targetName}: 짝사랑 (${val})\n`;
        else if(val < 0) relStr += `${targetName}: 적대 (${val})\n`;
      }
      relDiv.textContent = relStr.trim();
      card.appendChild(relDiv);

      // 수정/삭제 버튼
      const btnGroup = document.createElement('div');
      btnGroup.className = 'btn-group';
      const editBtn = document.createElement('button');
      editBtn.className = 'btn-small';
      editBtn.textContent = '수정';
      editBtn.onclick = () => editCharacter(idx);
      btnGroup.appendChild(editBtn);

      const delBtn = document.createElement('button');
      delBtn.className = 'btn-small btn-danger';
      delBtn.textContent = '삭제';
      delBtn.onclick = () => {
        if(confirm(`${char.name} 캐릭터를 삭제하시겠습니까?`)){
          state.characters.splice(idx,1);
          // 삭제 시 다른 캐릭터 관계에서도 제거
          state.characters.forEach(c => {
            delete c.relationships[char.name];
          });
          if(state.editingIndex === idx) {
            resetForm();
          }
          renderStudentList();
          drawRelation();
        }
      };
      btnGroup.appendChild(delBtn);

      card.appendChild(btnGroup);
      studentListDiv.appendChild(card);
    });
  }

  // 관계도 캔버스 초기화
  const ctx = relationCanvas.getContext('2d');
  function resizeCanvas(){
    relationCanvas.width = relationCanvas.clientWidth * devicePixelRatio;
    relationCanvas.height = relationCanvas.clientHeight * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
  }
  window.addEventListener('resize', () => {
    resizeCanvas();
    drawRelation();
  });

  // 관계도 그리기
  function drawRelation(){
    if(!showRelation) return;
    resizeCanvas();
    const w = relationCanvas.clientWidth;
    const h = relationCanvas.clientHeight;
    ctx.clearRect(0, 0, w, h);
    ctx.font = '13px Gowun Dodum, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const n = state.characters.length;
    if(n === 0) return;

    const centerX = w/2;
    const centerY = h/2;
    const radius = Math.min(w,h)/2 - 70;
    const nodeRadius = 30;

    // 위치 계산
    const pos = [];
    for(let i=0; i<n; i++){
      const angle = (2*Math.PI/n)*i - Math.PI/2;
      pos.push({
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle),
        angle
      });
    }

    // 선과 화살표 그리기 함수
    function drawArrow(ctx,x1,y1,x2,y2,color='#82a4d4'){
      const headlen = 10;
      const dx = x2 - x1;
      const dy = y2 - y1;
      const angle = Math.atan2(dy, dx);
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI/6), y2 - headlen * Math.sin(angle - Math.PI/6));
      ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI/6), y2 - headlen * Math.sin(angle + Math.PI/6));
      ctx.lineTo(x2, y2);
      ctx.fill();
    }

    // 노드 그리기 함수
    function drawNode(x,y,text){
      ctx.fillStyle = '#bbdefb';
      ctx.strokeStyle = '#1976d2';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(x, y, nodeRadius, nodeRadius, 0, 0, 2*Math.PI);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#0d47a1';
      ctx.font = 'bold 14px Gowun Dodum, sans-serif';
      ctx.fillText(text, x, y);
    }

    // 노드 위치 저장
    state.characters.forEach((char,i) => {
      char._pos = pos[i];
    });

    // 관계선 그리기
    for(let i=0; i<n; i++){
      const fromChar = state.characters[i];
      const fromPos = fromChar._pos;
      for(let targetName in fromChar.relationships){
        const toChar = state.characters.find(c=>c.name===targetName);
        if(!toChar) continue;
        const toPos = toChar._pos;
        if(!toPos) continue;

        const val = fromChar.relationships[targetName];
        // 색상
        let color = '#82a4d4'; // 기본 파랑
        if(val >= 50) color = '#1463bf'; // 파랑 진함
        else if(val < 0) color = '#d14646'; // 빨강
        else color = '#82a4d4'; // 연한 파랑

        // 선의 시작점과 끝점 조정 (노드 반지름만큼 뺌)
        const angle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);
        const startX = fromPos.x + 30 * Math.cos(angle);
        const startY = fromPos.y + 30 * Math.sin(angle);
        const endX = toPos.x - 30 * Math.cos(angle);
        const endY = toPos.y - 30 * Math.sin(angle);

        drawArrow(ctx, startX, startY, endX, endY, color);

        // 호감도 텍스트
        ctx.fillStyle = color;
        ctx.font = '12px Gowun Dodum, sans-serif';
        const midX = (startX + endX)/2;
        const midY = (startY + endY)/2 - 12;
        ctx.fillText(val, midX, midY);
      }
    }

    // 노드 그리기
    state.characters.forEach((char,i) => {
      drawNode(char._pos.x, char._pos.y, char.name);
    });
  }

  // 초기화 (폼)
  function resetForm(){
    formTitle.textContent = '캐릭터 추가';
    charNameInput.value = '';
    charAgeInput.value = '';
    charGradeSelect.value = '1';
    currentTraits = [];
    renderTraits();
    initialLikesContainer.innerHTML = '';
    addCharBtn.textContent = '추가';
    cancelEditBtn.style.display = 'none';
    state.editingIndex = null;
    updateInitialLikesUI();
  }

  // 캐릭터 수정 폼에 채우기
  function editCharacter(idx){
    const char = state.characters[idx];
    formTitle.textContent = '캐릭터 수정';
    charNameInput.value = char.name;
    charAgeInput.value = char.age;
    charGradeSelect.value = char.grade;
    currentTraits = [...char.traits];
    renderTraits();
    state.editingIndex = idx;
    addCharBtn.textContent = '수정';
    cancelEditBtn.style.display = 'inline-block';
    updateInitialLikesUI();
  }

  cancelEditBtn.addEventListener('click', () => {
    resetForm();
  });

  // 폼 제출
  charForm.addEventListener('submit', e => {
    e.preventDefault();
    const name = charNameInput.value.trim();
    const age = parseInt(charAgeInput.value);
    const grade = parseInt(charGradeSelect.value);

    if(!name){
      alert('이름을 입력하세요.');
      return;
    }
    if(age < 10 || age > 30){
      alert('나이를 10~30 사이로 입력하세요.');
      return;
    }

    if(state.editingIndex === null){
      // 중복 이름 체크
      if(state.characters.some(c=>c.name===name)){
        alert('이미 존재하는 이름입니다.');
        return;
      }
      // 추가
      const newChar = {
        name,
        age,
        grade,
        traits: [...currentTraits],
        relationships: {},
        status: '학생',
      };
      // 초기호감도 설정
      Array.from(initialLikesContainer.querySelectorAll('input')).forEach(input => {
        const target = input.dataset.target;
        const val = Number(input.value) || 0;
        newChar.relationships[target] = val;
      });

      // 반대로 기존 캐릭터들도 새 캐릭터에 대한 호감도 0으로 세팅
      state.characters.forEach(c=>{
        c.relationships[name] = 0;
      });

      state.characters.push(newChar);
      resetForm();
      renderStudentList();
      drawRelation();
    } else {
      // 수정 (이름 중복 허용하지 않음, 자기 자신 제외)
      if(state.characters.some((c,i) => c.name === name && i !== state.editingIndex)){
        alert('이미 존재하는 이름입니다.');
        return;
      }

      const char = state.characters[state.editingIndex];
      // 학년은 수정 가능 (요청에 따라 폼에서 학년 선택 가능)
      char.name = name;
      char.age = age;
      char.grade = grade;
      char.traits = [...currentTraits];

      // 초기호감도 수정 반영
      Array.from(initialLikesContainer.querySelectorAll('input')).forEach(input => {
        const target = input.dataset.target;
        const val = Number(input.value) || 0;
        char.relationships[target] = val;
      });

      // 이름 변경 시 다른 캐릭터 관계도 키 변경 (예: 이름 바뀌면)
      // (단순화 위해 이름 변경시 관계도 초기화 권장)
      // TODO: 필요하면 관계 키 동기화 코드 추가 가능

      resetForm();
      renderStudentList();
      drawRelation();
    }
  });

  // 날짜 포맷 함수
  function formatDate(d){
    const y = d.getFullYear();
    const m = d.getMonth() +1;
    const day = d.getDate();
    return `${y}년 ${m}월 ${day}일`;
  }

  // 오늘 이벤트 찾기
  function getEventByDate(d){
    const yyyyMMdd = d.toISOString().slice(0,10);
    return events.find(ev=>{
      return yyyyMMdd >= ev.start && yyyyMMdd <= ev.end;
    });
  }

  // 날짜 -> 계절 (3~5: 봄, 6~8: 여름, 9~11: 가을, 12~2: 겨울)
  function getSeason(d){
    const m = d.getMonth() + 1;
    if(m>=3 && m<=5) return '봄';
    if(m>=6 && m<=8) return '여름';
    if(m>=9 && m<=11) return '가을';
    return '겨울';
  }

  // 하루 일과 서술 생성기 (계절과 이벤트에 맞게, 성격키워드 최소 한두번만 등장)
  function generateDailyNarrative(char, date, eventName){
    const season = getSeason(date);
    const baseSentences = [
      `${char.name}은(는) 오늘도 평범한 하루를 보냈다.`,
      `${char.name}은(는) 학교에서 친구들과 웃으며 시간을 보냈다.`,
      `${char.name}은(는) ${season}의 분위기에 마음이 들떴다.`,
      `${char.name}은(는) 새로운 경험을 갈망하며 하루를 시작했다.`,
      `${char.name}은(는) 조용히 자신의 생각에 잠겼다.`,
    ];

    const traitSentences = {
      "활발한": [
        `${char.name}은(는) 활발하게 움직이며 주변 사람들과 어울렸다.`,
        `${char.name}은(는) 활기찬 모습으로 모두의 관심을 받았다.`,
      ],
      "내성적인": [
        `${char.name}은(는) 조용히 혼자 시간을 보내며 생각에 잠겼다.`,
        `${char.name}은(는) 내성적인 성격답게 깊은 대화를 나눴다.`,
      ],
      "친절한": [
        `${char.name}은(는) 친구들에게 다정한 말 한마디를 건넸다.`,
        `${char.name}은(는) 친절하게 도움을 주었다.`,
      ],
      "까다로운": [
        `${char.name}은(는) 조금 까다롭게 행동하며 주변을 곤란하게 했다.`,
        `${char.name}은(는) 완벽을 추구하며 조심스러웠다.`,
      ],
      "명랑한": [
        `${char.name}은(는) 명랑한 웃음으로 모두를 즐겁게 했다.`,
        `${char.name}은(는) 밝은 에너지로 분위기를 이끌었다.`,
      ],
      "조용한": [
        `${char.name}은(는) 조용히 자리를 지키며 차분하게 행동했다.`,
        `${char.name}은(는) 침착한 모습으로 친구들에게 신뢰를 받았다.`,
      ],
      // 기타 성격 키워드는 자유롭게 추가 가능
    };

    const eventStudySentences = [
      "열심히 공부를 했다.",
      "어려운 문제에서 막히기도 했지만 포기하지 않았다.",
      "집중해서 시험 준비를 했다.",
      "긴장했지만 최선을 다했다.",
      "교과서와 노트에 열심히 필기했다.",
    ];

    const eventTravelSentences = [
      "비가 왔지만 우산을 가져오지 않았다.",
      "그러나 친구가 우산을 같이 쓰자고 제안했다.",
      "날씨는 흐렸지만 모두의 기분은 밝았다.",
      "버스에서 친구들과 이야기를 나누며 웃었다.",
    ];

    // 한 날마다 성격 서술은 1~2개 정도만
    let traitSentencesUsed = 0;

    // 기본 서술 선택
    let narrative = baseSentences[Math.floor(Math.random()*baseSentences.length)];

    // 이벤트 서술
    if(eventName){
      if(eventName.includes('중간고사') || eventName.includes('기말고사')){
        narrative += ' ' + eventStudySentences[Math.floor(Math.random()*eventStudySentences.length)];
      }
      if(eventName.includes('수학여행')){
        narrative += ' ' + eventTravelSentences[Math.floor(Math.random()*eventTravelSentences.length)];
      }
      if(eventName.includes('방학')){
        narrative += ' 방학이라 평소보다 여유로운 시간을 보냈다.';
      }
      if(eventName.includes('체육대회')){
        narrative += ' 체육대회에서 친구들과 즐겁게 운동했다.';
      }
      if(eventName.includes('입학식')){
        narrative += ' 새로운 시작을 축하하며 입학식을 치렀다.';
      }
      if(eventName.includes('종업식') || eventName.includes('졸업식')){
        narrative += ' 졸업식을 맞아 감회가 새로웠다.';
      }
    }

    // 성격 키워드 서술 (최대 2개만)
    for(let t of char.traits){
      if(traitSentences[t] && traitSentencesUsed < 2){
        const arr = traitSentences[t];
        narrative += ' ' + arr[Math.floor(Math.random()*arr.length)];
        traitSentencesUsed++;
      }
    }

    return narrative;
  }

  // 호감도 및 관계 상태 업데이트 함수
  function updateRelationships(){
    // 랜덤 변화 (예: -5~5 범위)
    // 여기서 호감도 변화 로그 팝업 생성
    state.characters.forEach(char => {
      for(let otherName in char.relationships){
        let change = 0;
        if(Math.random() < 0.2){ // 20% 확률 변화
          change = Math.floor(Math.random()*11) - 5; // -5 ~ +5
          if(change !== 0){
            char.relationships[otherName] += change;
            // 0~100 클램핑
            if(char.relationships[otherName] > 100) char.relationships[otherName] = 100;
            if(char.relationships[otherName] < -50) char.relationships[otherName] = -50;
            // 변화 팝업
            if(change > 0){
              addLogPopup(`${char.name}의 ${otherName}에 대한 호감도가 ${change}만큼 올랐습니다.`, 'likeUp');
            } else if(change < 0){
              addLogPopup(`${char.name}의 ${otherName}에 대한 호감도가 ${-change}만큼 떨어졌습니다.`, 'likeDown');
            }
            // 관계 변화 체크
            checkRelationshipChange(char, otherName);
          }
        }
      }
    });
  }

  // 관계 상태 명칭 결정
  function getRelationStatus(val1, val2){
    // val1: char1->char2, val2: char2->char1
    function statusByVal(v){ // 호감도에 따른 상태
      if(v >= 80) return '약혼자';
      if(v >= 50) return '연인';
      if(v >= 20) return '썸';
      if(v > 0) return '짝사랑';
      if(v < 0) return '적대';
      return '무관심';
    }

    const s1 = statusByVal(val1);
    const s2 = statusByVal(val2);

    if(s1 === '짝사랑' && s2 === '짝사랑') return '썸';
    if(s1 === '썸' && s2 === '썸') return '썸';
    if(s1 === '연인' && s2 === '연인') return '연인';
    if(s1 === '약혼자' && s2 === '약혼자') return '약혼자';

    if(s1 === '짝사랑' && s2 > 0) return '짝사랑';
    if(s2 === '짝사랑' && s1 > 0) return '짝사랑';

    if(s1 === '적대' && s2 === '적대') return '적대';

    return '무관심';
  }

  // 관계 변화 이벤트 처리
  function checkRelationshipChange(char, otherName){
    const otherChar = state.characters.find(c => c.name === otherName);
    if(!otherChar) return;

    const val1 = char.relationships[otherName];
    const val2 = otherChar.relationships[char.name] || 0;

    const prevStatus = (char._lastRel && char._lastRel[otherName]) || '무관심';
    const curStatus = getRelationStatus(val1, val2);

    if(prevStatus !== curStatus){
      // 이벤트 로그
      addLogPopup(`${char.name}와(과) ${otherName}의 관계가 '${prevStatus}'에서 '${curStatus}'로 변했습니다.`, 'relationChange');
    }

    // 저장 현재 상태
    if(!char._lastRel) char._lastRel = {};
    char._lastRel[otherName] = curStatus;
  }

  // 로그 팝업 추가
  function addLogPopup(text, type='event'){
    const dateStr = formatDate(state.currentDate);
    const popupDiv = document.createElement('div');
    popupDiv.className = 'popup';
    if(type === 'likeUp') popupDiv.classList.add('likeUp');
    else if(type === 'likeDown') popupDiv.classList.add('likeDown');
    else if(type === 'relationChange') popupDiv.classList.add('relationChange');
    else popupDiv.classList.add('event');
    popupDiv.textContent = `[${dateStr}] ${text}`;
    dayLog.prepend(popupDiv);
  }

  // 하루 진행
  function nextDay(){
    // 날짜 증가
    state.currentDate.setDate(state.currentDate.getDate() + 1);

    // 이벤트 확인 및 로그
    const todayEvent = getEventByDate(state.currentDate);
    if(todayEvent){
      addLogPopup(`오늘은 '${todayEvent.name}' 일정이 있습니다.`, 'event');
    }

    // 관계도 변화 업데이트
    updateRelationships();

    // 오늘 하루 서술 생성 및 출력
    let narrativeText = `--- ${formatDate(state.currentDate)} ---\n`;
    state.characters.forEach(char => {
      narrativeText += generateDailyNarrative(char, state.currentDate, todayEvent ? todayEvent.name : '') + '\n\n';
    });

    // 하루 서술은 로그 아래에 추가 (div)
    const narrativeDiv = document.createElement('div');
    narrativeDiv.style.marginTop = '12px';
    narrativeDiv.style.borderTop = '1px solid #ddd';
    narrativeDiv.style.paddingTop = '6px';
    narrativeDiv.style.whiteSpace = 'pre-line';
    narrativeDiv.textContent = narrativeText;
    dayLog.prepend(narrativeDiv);

    dateTitle.textContent = `현재 날짜: ${formatDate(state.currentDate)}`;

    renderStudentList();
    drawRelation();
  }

  // 초기화 & 첫 렌더링
  resetForm();
  renderStudentList();
  drawRelation();
  dateTitle.textContent = `현재 날짜: ${formatDate(state.currentDate)}`;
  dayLog.textContent = '시작하려면 "다음 날" 버튼을 눌러주세요.';

  nextDayBtn.addEventListener('click', nextDay);
  clearLogBtn.addEventListener('click', () => {
    if(confirm('기록을 삭제하시겠습니까?')){
      dayLog.textContent = '';
    }
  });
</script>
</body>
</html>
